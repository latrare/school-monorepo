	All that is required to run my cracker is Python 3.5.2 (the latest version of Python). Earlier versions of Python 3 may work just fine, this is simply the version that I developed with. Usage is described by running "python main.py -h". Design decisions are pretty easy to explain: dictionary file is used to generate a "1337 dictionary" using the "leetgen.py" script. Both of those dictionaries are then loaded into the program and have sha256 hashes generated for each of their entries. The original dictionary hash generation is done in a single thread because it executes fast enough. The 1337 dictionary hash generation is done in parallel as there are many more 1337 mutations of each dictionary entry than there are plain dictionary entries. Bruteforcing is of course done in parallel and is the result of a cross product of all printable ASCII characters. All choices were to simplify batch processing of hashes and to increase the efficiency with which the cracker could go through all of the different hashes that needed to be generated. A system designer could simply use something along the lines of bcrypt/scrypt with a high difficulty argument and even my most rudimentary bruteforcing would be infuriatingly slow. System designers could also just require that user passwords are at least 8 characters in length and have at least 1 character from each major non-alpha ASCII character set (i.e. 1 digit, 1 punctuation) and ensure that a unique salt is used, per user, when generating the hash for the password to store in the DB. Adding the salt inherently slows down the hash generation process. However, its use is specifically to prevent the use of rainbow tables on a list of password hashes as the unique salt per password requires the hash for the password to try to be regenerated.
